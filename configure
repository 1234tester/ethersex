#! /usr/bin/perl -w
# Copyright (c) 2007 by Stefan Siegl <stesie@brokenpipe.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# For more information on the GPL, please go to:
# http://www.gnu.org/copyleft/gpl.html

use strict;
use Term::Prompt;

my %ethersex_modules = (
  'tetrirape' => {
                   helptext  => "a tetrinet server",
                   conflicts => [ "ecmd", "bootloader" ],
                   distdflt  => 0,
                 },
  'ecmd'      => { 
                   helptext  => "telnet-based etherrape control interface",
                   conflicts => [ "tetrirape", "bootloader" ],
                   requires  => [ "tcp", "portio" ],
                   distdflt  => 1,
                 },
  'portio'    => {
                   helptext  => "port io abstraction layer",
                   distdflt  => 0,
                   virtual   => 1,
                 },
  'named_pin'  => {
                   helptext => "pins with names and logic states",
                   requires  => [ "portio" ],
                   distdflt => 0,
                 },
  'ecmd_sender'  => {
                   helptext => "send an ecmd to another host",
                   requires => ["tcp"],
                   distdflt => 0,
                 },
  'watchcat'  => {
                   helptext => "watch io changes and react",
                   requires => ["ecmd_sender", "portio"],
                   distdflt => 0,
                 },
  'fs20'      => { 
                   helptext  => "fs20 rf-control interface",
                   distdflt  => 0,
                   conflicts => [ "bootloader" ],
                 },
  'bootp'     => { 
                   helptext  => "DHCP-like autoconfig for IPv4",
                   conflicts => [ "ipv6", "tftpomatic" ],
                   requires  => [ "broadcast", "udp" ],
                   preconfigure => [ "ipv6" ],
                   distdflt  => 0,
                 },
  'ipv6'      => { 
                   helptext  => "IPv6 support instead of IPv4",
                   conflicts => [ "bootp" ],
                   distdflt  => 1,
                   disable_hook  => \&ipv6_disable_hook,
                 },
  'broadcast' => { 
                   helptext  => "broadcast support",
                   requires  => [ "udp" ],
                   distdflt  => 0,
                 },
  'udp'       => { 
                   helptext  => "udp support",
                   distdflt  => 1,
                 },
  'tcp'       => { 
                   helptext  => "tcp support",
                   distdflt  => 1,
                 },
  'tftpomatic'=> {
                   helptext  => "automatic firmware loading using tftp",
                   requires  => [ "tftp" ],
                   conflicts => [ "bootp" ],
                   preconfigure => [ "ipv6", "bootp" ],
                   enable_hook  => \&tftpomatic_enable_hook,
                   distdflt  => 0,
                 },
  'tftp'      => { 
                   helptext  => "TFTP-based firmware bootloader",
                   requires  => [ "bootloader", "udp" ],
                   preconfigure => [ "tftpomatic", "skipjack" ],
                   enable_hook  => \&tftp_enable_hook,
                   distdflt  => 0,
                 },
  'hd44780'   => {
                   helptext  => "Character-LCD module driver",
                   distdflt  => 0,
                 },
  'bootloader'=> {
                   helptext  => "configure as bootloader",
                   distdflt  => 0,
                 },
  'rc4'       => {
                   helptext  => "a stream cipher",
                   requires  => [ "crypto", "md5", "tcp" ],
                   distdflt  => 0,
                   preconfigure => [ "tcp" ],
                 },
  'auth'      => {
                   helptext  => "tcp connection authentication",
                   distdflt  => 0,
                 },
  'skipjack'  => {
                   helptext  => "skipjack block cipher",
                   requires  => [ "auth", "crypto" ],
                   conflicts => [ "cast5" ],
                   distdflt  => 0,
                 },
  'cast5'     => {
                   helptext  => "cast5 block cipher",
                   requires  => [ "auth", "crypto" ],
                   conflicts => [ "skipjack", "bootloader" ],
                   distdflt  => 0,
                 },
  'md5'       => {
                   helptext  => "md5 hash support",
                   requires  => [ "crypto" ],
                   distdflt  => 0,
                   virtual   => 1,
                 },
  'crypto'    => {
                   helptext  => "generic crypto support",
                   distdflt  => 0,
                   virtual   => 1,
                 },
  'onewire'    => {
                   helptext  => "onewire device support",
                   distdflt  => 0,
                 },
  'rc5'        => {
                   helptext  => "sending rc5 IR codes",
                   distdflt  => 0,
                 },
  'dns'        => {
                   helptext  => "dns name resolver",
                   distdflt  => 0,
                   requires => ["udp"],
                   preconfigure => [ "ipv6", "bootp" ],
                   enable_hook  => \&dns_enable_hook,
                 },
  'dyndns'        => {
                   helptext  => "updating an dns name on dyn.metafnord.de",
                   distdflt  => 0,
                   requires => ["tcp"],
                   enable_hook  => \&dyndns_enable_hook,
                 },
  'syslog'        => {
                   helptext  => "sending syslog messages",
                   distdflt  => 0,
                   requires => ["udp"],
                   enable_hook  => \&syslog_enable_hook,
                 },
  'i2c'        => {
                   helptext  => "i2c to udp gateway",
                   distdflt  => 0,
                   requires => ["udp"],
                 },
);
my %ethersex_config = (
  'etherrape_ip4'   => {
                   helptext  => "default ip address of the etherrape",
                 },
  'etherrape_ip4_netmask'   => {
                   helptext  => "default netmask for ipv4",
                 },
  'etherrape_ip4_gateway'   => {
                   helptext  => "default gateway for ipv4",
                 },
  'etherrape_mac'   => {
                   helptext  => "mac address of the etherrape",
                 },
  'tftp_ip'   => {
                   helptext  => "ip address of tftp server",
                 },
  'tftp_image' =>{
                   helptext  => "name of tftp image to download",
                 },
  'tftp_key'   =>{
                   helptext  => "hex-encoded skipjack key for tftp",
                 },
  'dns_server' =>{
                   helptext  => "ip address of the default dns server",
                 },
  'dyndns_hostname' => {
                   helptext  => "hostname to be updated via dyndns",
                },
  'dyndns_username' => {
                   helptext  => "hostname to be updated via dyndns",
                },
  'dyndns_password' => {
                   helptext  => "hostname to be updated via dyndns",
                },
  'syslog_server' => {
                   helptext  => "ip address of the syslog server",
                },
);


my $opt_restore_defaults = 0;
my $opt_only_modules = 0;
foreach(@ARGV) {
  if(m/--restore-defaults/) { $opt_restore_defaults = 1; }
  if(m/--only-modules/) { $opt_only_modules = 1; }
  if(m/--help/ or m/-h/) { 
    print STDERR "ethersex configuration utility\n";
    print STDERR "  --restore-defaults  - enable only default modules\n";
    print STDERR "  --only-modules      - configure only the modules\n";
    exit 0;
  }
}

#
# scan `config.h' for enabled/disabled modules
#
open HANDLE, "< config.h"
  or die "unable to read config.h file";
while(<HANDLE>) {
  chop $_;
  if(my ($enabled, $modname) = 
     m/^(\/*|\/\/)?\s*#define\s+([A-Z0-9_]+)_SUPPORT\s*(?:\*\/)?\s*$/) {

    unless(defined($ethersex_modules{lc($modname)})) {
      warn "unknown ethersex module '" . lc($modname) . "' listed in config.h";
      next;
    }

    $ethersex_modules{lc($modname)}->{'enabled'} = !length($enabled);
  }
  if(my ($confopt, $confvalue) =
     m/#define\s+CONF_([A-Z0-9_]+)\s+(.*)$/) {

    unless(defined($ethersex_config{lc($confopt)})) {
      warn "unknown ethersex config '" . lc($confopt) . "' listed in config.h";
      next;
    }

    $ethersex_config{lc($confopt)}->{'value'} = $confvalue;
  }
}
close HANDLE or die;


# check whether module may be enabled
# return: 1 if conflicting (message will be emitted)
my @enable_modules;
sub try_enable {
  my $module = shift;
  my $trymodule = shift;

  unless(defined($trymodule)) { $trymodule = $module }

  foreach my $module_conflicts (@{$ethersex_modules{$module}->{'conflicts'}}) {
    foreach (@enable_modules) {
      if($_ eq $module_conflicts) {
        printf "disabling %s (conflicts with %s).\n", $trymodule, $_;
        disable($trymodule);

        return 1;
      }
    }
  }

  foreach (@{$ethersex_modules{$module}->{'requires'}}) {
    if(defined($ethersex_modules{$_}->{'new_status'})
       && !$ethersex_modules{$_}->{'new_status'}) {
      printf "disabling %s (would require %s).\n", $trymodule, $_;
      disable($trymodule);

      return 1;
    }
    if(try_enable($_, $trymodule)) {
      return 1;
    }
  }

  return 0;
}

sub enable {
  my $module = shift;
  my $requiring = shift;

  return if($ethersex_modules{$module}->{'new_status'});

  if(defined($requiring)) {
    printf "enabling %s (required by %s).\n", $module, $requiring;
  } else {
    $requiring = $module;
  }

  foreach (@{$ethersex_modules{$module}->{'requires'}}) {
    enable($_, $requiring);
  }

  $ethersex_modules{$module}->{'new_status'} = 1;
  push @enable_modules, $module;

  # call hook, if available
  if(defined($ethersex_modules{$module}->{'enable_hook'})) {
    $ethersex_modules{$module}->{'enable_hook'}();
  }
}

sub disable {
  my $module = shift;
  $ethersex_modules{$module}->{'new_status'} = 0;

  # call hook, if available
  if(defined($ethersex_modules{$module}->{'disable_hook'})) {
    $ethersex_modules{$module}->{'disable_hook'}();
  }
}


# configure module (return 1, if config has been changed, 0 otherwise)
sub configure_module {
  my ($module) = @_;

 restart:
  # check whether we've already asked the user (or implied an answer)
  return(0) if(defined($ethersex_modules{$module}->{'new_status'}));

  return(0) if(try_enable($module));  # cannot enable, conflicting.

  # perform forced preconfiguration ...
  if(defined($ethersex_modules{$module}->{'preconfigure'})) {
    foreach (@{$ethersex_modules{$module}->{'preconfigure'}}) {
      if(configure_module($_)) { goto restart; }
    }
  }

  # automatic handling of virtual modules ...
  if($ethersex_modules{$module}->{'virtual'}) {
    # configure all modules depending on this module
    foreach (keys %ethersex_modules) { 
      next if $_ eq $module;
      next unless defined $ethersex_modules{$_}->{'requires'};
      foreach my $dependency (@{$ethersex_modules{$_}->{'requires'}}) {
        if($dependency eq $module) {
          if(configure_module($_)) { goto restart; }
        }
      }
    }
    
    print "disabling unneeded, virtual module $module.\n";
    disable $module;
    return 1;
  }

  my $answer;
  if($opt_restore_defaults) { 
    $answer = $ethersex_modules{$module}->{'distdflt'};
    printf "%s %s.\n", ($answer ? "enabling" : "disabling"), $module;
  }
  else {
    $answer = prompt('y', sprintf("enable %s?", $module),
                     $ethersex_modules{$module}->{'helptext'}, 
                     $ethersex_modules{$module}->{'enabled'});
  }

  if($answer) {
    enable($module);
  } 
  else {
    disable($module);
  }

  return 1;
}

sub ipv6_expand {
  $_ = shift;
  my @colons = m/:/g;
  if(scalar(@colons) > 7) { return undef; }
  unless(m/::/) { return $_ }

  my $replacement = ":0" x (8 - scalar(@colons)) . ":";
  $_ =~ s/::/$replacement/;
  if($_ =~ m/^:/) { $_ = "0$_"; }
  if($_ =~ m/:$/) { $_ .= "0"; }

  return $_;
}

# return 1 if provided IP address is valid
sub check_ip {
  my $checkval = shift;
  unless($ethersex_modules{'ipv6'}->{'new_status'}) {
    # validate ipv4 addr
    my @parts = split m/\./, $checkval;
    if(scalar(@parts) != 4) { return 0; }
    foreach(@parts) {
      if($_ < 0 || $_ > 255) { return 0; }
    }
    return 1;
  }

  # validate ipv6 addr
  if($checkval =~ m/:::/) { return 1; }
  $checkval = ipv6_expand($checkval);
  if($checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){7}$/i) { return 1; }
  return 0;
}

sub ask_ip {
  my $confopt = shift;
 
  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }
  for($default) { s/0x//g; s/\s//g; s/^uip_ip6?addr\(ip,//; s/\)$//; }
  my $separator = $ethersex_modules{'ipv6'}->{'new_status'} ? ":" : ".";
  $default = join($separator, split(m/,/, $default));
  unless (check_ip($default)) { $default = "" }

  my $new_value = 
    prompt('s', $confopt . "?", $ethersex_config{$confopt}->{'helptext'}, 
           $default, \&check_ip);

  if($ethersex_modules{'ipv6'}->{'new_status'} && $new_value =~ m/::/) {
    $new_value = ipv6_expand($new_value);
  }

  my @parts = split(m/[\.:]/, $new_value);
  if($ethersex_modules{'ipv6'}->{'new_status'}) {
    foreach(@parts) { $_ = "0x" . $_ }
  }
  $ethersex_config{$confopt}->{'value'} = "uip_" .
    ($ethersex_modules{'ipv6'}->{'new_status'} ? "ip6addr" : "ipaddr") . "(ip,"
    . join(",", @parts) . ")"; 
}

sub check_mac {
  my $checkval = shift;
  if ($checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){5}$/i) { return 1;}
  return 0;
}

sub ask_mac {
  my $confopt = shift;

  if($opt_restore_defaults) {
    $ethersex_config{$confopt}->{'value'} = '"\xAC\xDE\x48\xFD\x0F\xD0"';
    return;
  }

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  for($default) { s/"//g; s/\\x/:/g; s/^:// };
  my $new_value =
    prompt('s', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, \&check_mac);
  for($new_value) {s/:/\\x/g }
  
  $ethersex_config{$confopt}->{'value'} = '"\\x' . $new_value . '"';
}

sub ask_anything {
  my $confopt = shift;
 
  my $d = $ethersex_config{$confopt}->{'value'};
  unless(defined($d)) { $d = ""; }
  for($d) { s/^"//; s/"$//; }

  my $v =
    prompt('x', $confopt . "?", $ethersex_config{$confopt}->{'helptext'}, $d); 
  $ethersex_config{$confopt}->{'value'} = "\"$v\"";
}

# check key validity, return 0 if invalid.
sub check_cryptokey {
  my $checkval = shift;
  my $keylen = shift;

  unless (length ($checkval) == $keylen * 2) { return 0; }
  unless ($checkval =~ m/^[0-9a-f]+$/i) { return 0; }
  return 1;
}

sub ask_cryptokey {
  my $confopt = shift;
  my $keylen = shift;

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  for($default) { s/"//g; s/\\x//g; };
  my $new_value =
    prompt('s', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, 
           sub { 
             my $a = shift; 
             return check_cryptokey ($a, $keylen); 
           } );

  $new_value =~ s/(..)/\\x$1/g;
  $ethersex_config{$confopt}->{'value'} = "\"$new_value\"";
}

sub tftpomatic_enable_hook {
  # don't ask for tftp image, if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});

  ask_ip("tftp_ip");
  ask_anything("tftp_image");
}

sub tftp_enable_hook {
  # ask for crypto key only if skipjack enabled.
  return unless($ethersex_modules{'skipjack'}->{'new_status'});

  ask_cryptokey("tftp_key", 10);
}

sub ipv6_disable_hook {
  # ask user for bootp
  configure_module "bootp";

  # don't aks default ip when user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});
  
  ask_ip("etherrape_ip4");
  ask_ip("etherrape_ip4_netmask");
  ask_ip("etherrape_ip4_gateway");
}

sub dns_enable_hook {
  # don't ask for dns server, if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});

  ask_ip("dns_server");
}

sub dyndns_enable_hook {
  ask_anything("dyndns_hostname");
  ask_anything("dyndns_username");
  ask_anything("dyndns_password");
}

sub syslog_enable_hook {
  ask_ip("syslog_server");
}




#
# ask user which modules to enable
#
if ( $opt_only_modules != 1) {
  print "\n\n -= ETHERSEX CONFIGURATION =-\n\n";
  ask_mac "etherrape_mac";
  configure_module "bootloader";
  foreach my $module (keys %ethersex_modules) { configure_module($module) }
}


#
# update config files ...
#
sub write_config {
  my $filename = shift;
  print "writing $filename.\n";

  open INHANDLE, "< $filename"
    or die "unable to open $filename for reading";
  open OUTHANDLE, "> $filename.new"
    or die "unable to open $filename.new for writing";

  while(my $confline = <INHANDLE>) {
    chop $confline;
    my ($enabled, $modname, $line);

    # enable/disable config.h support flag
    if(($enabled, $modname) = $confline =~
       m/^(\/*|\/\/)?\s*#define\s+([A-Z0-9_]+)_SUPPORT\s*(?:\*\/)?\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "// ") . "#define " . $modname . "_SUPPORT";
      }
      # commit config for later module configuration
      $ethersex_modules{lc($modname)}->{'enabled'} =
        $ethersex_modules{lc($modname)}->{'new_status'};
    }

    # enable/disable Makefile SRC variable editing
    elsif(($modname) = $confline =~
       m/^#*\s*SRC\s*\+=\s*\$\(shell echo ([a-z0-9_]+)\/\*\.c\)\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "#") . "SRC += \$(shell echo $modname/*.c)";
      }
    }

    # enable/disable Makefile lines ...
    elsif(($line, $modname) = $confline =~
       m/^#*\s*([^#]+#\s*([A-Z0-9_]+)_SUPPORT)\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "#") . $line;
      }
    }

    # write configuration option
    elsif(($modname) = $confline =~
          m/#define\s+CONF_([A-Z0-9_]+)\s+/) {

      if(defined($ethersex_config{lc($modname)})) {
        $confline = "#define CONF_$modname " 
          . $ethersex_config{lc($modname)}->{'value'};
      }
    }

    print OUTHANDLE "$confline\n";
  }

  close INHANDLE or die;
  close OUTHANDLE or die;

  unlink("$filename") or die;
  rename("$filename.new", "$filename") or die;
}

#
# write the config files
#
if ($opt_only_modules != 1) {
  foreach(qw/config.h Makefile/) {
    write_config($_);
  }
}

sub modules_configuration {
  my %configure_modules = ();

  foreach my $module (keys %ethersex_modules) {
    if (-e("$module/configure") and -e("$module/cfgpp")
        and $ethersex_modules{$module}->{'enabled'}) {
      $configure_modules{$module} = $ethersex_modules{$module};
    }
  }
  return unless scalar(keys %configure_modules);

  my $choice;
  do {
    print "\n== configure ethersex modules ==\n\n";
    my $x = 1;
    foreach my $t (keys(%configure_modules)) {
      print "$x. $t - " . $configure_modules{$t}->{'helptext'} . "\n";
      $x++;
    }
    print "\n0. Exit\n";

    $choice = prompt('n', 'Please Choose:', '', '0');
    if($choice > scalar(keys %configure_modules)) {
      print "invalid choice, try again.\n\n";
      next;
    }

    if($choice) {
      system((keys(%configure_modules))[$choice - 1] . "/configure");
    }

  } while ($choice);
}

#
# configure the selected modules
#

modules_configuration

print "\n\nsuccessfully configured your ethersex.\n";
print "don't forget to run `make clean all'.\n\n";
