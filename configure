#! /usr/bin/perl -w
# Copyright (c) 2007 by Stefan Siegl <stesie@brokenpipe.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# For more information on the GPL, please go to:
# http://www.gnu.org/copyleft/gpl.html

use strict;
use Term::Prompt;

my %ethersex_modules = (
  'tetrirape' => {
                   helptext  => "a tetrinet server",
                   conflicts => [ "ecmd", "bootloader" ],
                   distdflt  => 0,
                 },
  'ecmd'      => { 
                   helptext  => "telnet-based etherrape control interface",
                   conflicts => [ "tetrirape", "bootloader" ],
                   requires  => [ "tcp", "portio" ],
                   distdflt  => 1,
                 },
  'portio'    => {
                   helptext  => "port io abstraction layer",
                   distdflt  => 0,
                   virtual   => 1,
                 },
  'ecmd_sender'  => {
                   helptext => "send an ecmd to another",
                   requires => ["tcp"],
                   distdflt => 1,
                 },
  'watchcat'  => {
                   helptext => "watch io changes and react",
                   requires => ["ecmd_sender", "portio"],
                   distdflt => 1,
                 },
  'fs20'      => { 
                   helptext  => "fs20 rf-control interface",
                   distdflt  => 0,
                   conflicts => [ "bootloader" ],
                 },
  'bootp'     => { 
                   helptext  => "DHCP-like autoconfig for IPv4",
                   conflicts => [ "ipv6", "tftpomatic" ],
                   requires  => [ "broadcast", "udp" ],
                   preconfigure => [ "ipv6" ],
                   distdflt  => 0,
                 },
  'ipv6'      => { 
                   helptext  => "IPv6 support instead of IPv4",
                   conflicts => [ "bootp" ],
                   distdflt  => 1,
                 },
  'broadcast' => { 
                   helptext  => "broadcast support",
                   requires  => [ "udp" ],
                   distdflt  => 0,
                 },
  'udp'       => { 
                   helptext  => "udp support",
                   distdflt  => 1,
                 },
  'tcp'       => { 
                   helptext  => "tcp support",
                   distdflt  => 1,
                 },
  'tftpomatic'=> {
                   helptext  => "automatic firmware loading using tftp",
                   requires  => [ "tftp" ],
                   conflicts => [ "bootp" ],
                   preconfigure => [ "ipv6", "bootp" ],
                   enable_hook  => \&tftpomatic_enable_hook,
                   distdflt  => 0,
                 },
  'tftp'      => { 
                   helptext  => "TFTP-based firmware bootloader",
                   requires  => [ "bootloader", "udp" ],
                   preconfigure => [ "tftpomatic" ],
                   distdflt  => 0,
                 },
  'hd44780'   => {
                   helptext  => "Character-LCD module driver",
                   distdflt  => 0,
                 },
  'bootloader'=> {
                   helptext  => "configure as bootloader",
                   distdflt  => 0,
                 },
  'rc4'       => {
                   helptext  => "a stream cipher",
                   requires  => [ "crypto", "md5", "tcp" ],
                   distdflt  => 0,
                   preconfigure => [ "tcp" ],
                 },
  'auth'      => {
                   helptext  => "tcp connection authentication",
                   distdflt  => 0,
                 },
  'skipjack'  => {
                   helptext  => "skipjack block cipher",
                   requires  => [ "auth", "crypto" ],
                   conflicts => [ "cast5" ],
                   distdflt  => 0,
                 },
  'cast5'     => {
                   helptext  => "cast5 block cipher",
                   requires  => [ "auth", "crypto" ],
                   conflicts => [ "skipjack", "bootloader" ],
                   distdflt  => 0,
                 },
  'md5'       => {
                   helptext  => "md5 hash support",
                   requires  => [ "crypto" ],
                   distdflt  => 0,
                   virtual   => 1,
                 },
  'crypto'    => {
                   helptext  => "generic crypto support",
                   distdflt  => 0,
                   virtual   => 1,
                 },
);
my %ethersex_config = (
  'tftp_ip'   => {
                   helptext  => "ip address of tftp server",
                 },
  'tftp_image' =>{
                   helptext  => "name of tftp image to download",
                 },
);

my $opt_restore_defaults = 0;
foreach(@ARGV) {
  if(m/--restore-defaults/) { $opt_restore_defaults = 1; }
}

#
# scan `config.h' for enabled/disabled modules
#
open HANDLE, "< config.h"
  or die "unable to read config.h file";
while(<HANDLE>) {
  chop $_;
  if(my ($enabled, $modname) = 
     m/^(\/*|\/\/)?\s*#define\s+([A-Z0-9_]+)_SUPPORT\s*(?:\*\/)?\s*$/) {

    unless(defined($ethersex_modules{lc($modname)})) {
      warn "unknown ethersex module '" . lc($modname) . "' listed in config.h";
      next;
    }

    $ethersex_modules{lc($modname)}->{'enabled'} = !length($enabled);
  }
  if(my ($confopt, $confvalue) =
     m/#define\s+CONF_([A-Z0-9_]+)\s+(.*)$/) {

    unless(defined($ethersex_config{lc($confopt)})) {
      warn "unknown ethersex config '" . lc($confopt) . "' listed in config.h";
      next;
    }

    $ethersex_config{lc($confopt)}->{'value'} = $confvalue;
  }
}
close HANDLE or die;


# check whether module may be enabled
# return: 1 if conflicting (message will be emitted)
my @enable_modules;
sub try_enable {
  my $module = shift;
  my $trymodule = shift;

  unless(defined($trymodule)) { $trymodule = $module }

  foreach my $module_conflicts (@{$ethersex_modules{$module}->{'conflicts'}}) {
    foreach (@enable_modules) {
      if($_ eq $module_conflicts) {
        printf "disabling %s (conflicts with %s).\n", $trymodule, $_;
        disable($trymodule);

        return 1;
      }
    }
  }

  foreach (@{$ethersex_modules{$module}->{'requires'}}) {
    if(defined($ethersex_modules{$_}->{'new_status'})
       && !$ethersex_modules{$_}->{'new_status'}) {
      printf "disabling %s (would require %s).\n", $trymodule, $_;
      disable($trymodule);

      return 1;
    }
    if(try_enable($_, $trymodule)) {
      return 1;
    }
  }

  return 0;
}

sub enable {
  my $module = shift;
  my $requiring = shift;

  return if($ethersex_modules{$module}->{'new_status'});

  if(defined($requiring)) {
    printf "enabling %s (required by %s).\n", $module, $requiring;
  } else {
    $requiring = $module;
  }

  foreach (@{$ethersex_modules{$module}->{'requires'}}) {
    enable($_, $requiring);
  }

  $ethersex_modules{$module}->{'new_status'} = 1;
  push @enable_modules, $module;

  # call hook, if available
  if(defined($ethersex_modules{$module}->{'enable_hook'})) {
    $ethersex_modules{$module}->{'enable_hook'}();
  }
}

sub disable {
  my $module = shift;
  $ethersex_modules{$module}->{'new_status'} = 0;

  # call hook, if available
  if(defined($ethersex_modules{$module}->{'disable_hook'})) {
    $ethersex_modules{$module}->{'disable_hook'}();
  }
}


# configure module (return 1, if config has been changed, 0 otherwise)
sub configure_module {
  my ($module) = @_;

 restart:
  # check whether we've already asked the user (or implied an answer)
  return(0) if(defined($ethersex_modules{$module}->{'new_status'}));

  return(0) if(try_enable($module));  # cannot enable, conflicting.

  # perform forced preconfiguration ...
  if(defined($ethersex_modules{$module}->{'preconfigure'})) {
    foreach (@{$ethersex_modules{$module}->{'preconfigure'}}) {
      if(configure_module($_)) { goto restart; }
    }
  }

  # automatic handling of virtual modules ...
  if($ethersex_modules{$module}->{'virtual'}) {
    # configure all modules depending on this module
    foreach (keys %ethersex_modules) { 
      next if $_ eq $module;
      next unless defined $ethersex_modules{$_}->{'requires'};
      foreach my $dependency (@{$ethersex_modules{$_}->{'requires'}}) {
        if($dependency eq $module) {
          if(configure_module($_)) { goto restart; }
        }
      }
    }
    
    print "disabling unneeded, virtual module $module.\n";
    disable $module;
    return 1;
  }

  my $answer;
  if($opt_restore_defaults) { 
    $answer = $ethersex_modules{$module}->{'distdflt'};
    printf "%s %s.\n", ($answer ? "enabling" : "disabling"), $module;
  }
  else {
    $answer = prompt('y', sprintf("enable %s?", $module),
                     $ethersex_modules{$module}->{'helptext'}, 
                     $ethersex_modules{$module}->{'enabled'});
  }

  if($answer) {
    enable($module);
  } 
  else {
    disable($module);
  }

  return 1;
}

sub check_ip {
  my $checkval = shift;
  if($ethersex_modules{'ipv6'}->{'new_status'}) {
    # validate ipv6 addr
    if($checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){7}$/i) { return 1; }
    return 0;
  } else {
    # validate ipv4 addr
    my @parts = split m/\./, $checkval;
    if(scalar(@parts) != 4) { return 0; }
    foreach(@parts) {
      if($_ < 0 || $_ > 255) { return 0; }
    }
    return 1;
  }
}

sub ask_ip {
  my $confopt = shift;
 
  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }
  for($default) { s/0x//g; s/\s//g; s/^uip_ip6?addr\(ip,//; s/\)$//; }
  my $separator = $ethersex_modules{'ipv6'}->{'new_status'} ? ":" : ".";
  $default = join($separator, split(m/,/, $default));
  unless (check_ip($default)) { $default = "" }

  my $new_value = 
    prompt('s', $confopt . "?", $ethersex_config{$confopt}->{'helptext'}, 
           $default, \&check_ip);

  my @parts = split(m/[\.:]/, $new_value);
  if($ethersex_modules{'ipv6'}->{'new_status'}) {
    foreach(@parts) { $_ = "0x" . $_ }
  }
  $ethersex_config{$confopt}->{'value'} = "uip_" .
    ($ethersex_modules{'ipv6'}->{'new_status'} ? "ip6addr" : "ipaddr") . "(ip,"
    . join(",", @parts) . ")"; 
}

sub ask_anything {
  my $confopt = shift;
 
  my $d = $ethersex_config{$confopt}->{'value'};
  unless(defined($d)) { $d = ""; }
  for($d) { s/^"//; s/"$//; }

  my $v =
    prompt('x', $confopt . "?", $ethersex_config{$confopt}->{'helptext'}, $d); 
  $ethersex_config{$confopt}->{'value'} = "\"$v\"";
}

sub tftpomatic_enable_hook {
  # don't ask for tftp image, if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});

  ask_ip("tftp_ip");
  ask_anything("tftp_image");
}

#
# ask user which modules to enable
#
print "\n\n -= ETHERSEX CONFIGURATION =-\n\n";
configure_module "bootloader";
foreach my $module (keys %ethersex_modules) { configure_module($module) }


#
# update config files ...
#
sub write_config {
  my $filename = shift;
  print "writing $filename.\n";

  open INHANDLE, "< $filename"
    or die "unable to open $filename for reading";
  open OUTHANDLE, "> $filename.new"
    or die "unable to open $filename.new for writing";

  while(my $confline = <INHANDLE>) {
    chop $confline;
    my ($enabled, $modname, $line);

    # enable/disable config.h support flag
    if(($enabled, $modname) = $confline =~
       m/^(\/*|\/\/)?\s*#define\s+([A-Z0-9_]+)_SUPPORT\s*(?:\*\/)?\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "// ") . "#define " . $modname . "_SUPPORT";
      }
    }

    # enable/disable Makefile SRC variable editing
    elsif(($modname) = $confline =~
       m/^#*\s*SRC\s*\+=\s*\$\(shell echo ([a-z0-9]+)\/\*\.c\)\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "#") . "SRC += \$(shell echo $modname/*.c)";
      }
    }

    # enable/disable Makefile lines ...
    elsif(($line, $modname) = $confline =~
       m/^#*\s*([^#]+#\s*([A-Z0-9_]+)_SUPPORT)\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "#") . $line;
      }
    }

    # write configuration option
    elsif(($modname) = $confline =~
          m/#define\s+CONF_([A-Z0-9_]+)\s+/) {

      if(defined($ethersex_config{lc($modname)})) {
        $confline = "#define CONF_$modname " 
          . $ethersex_config{lc($modname)}->{'value'};
      }
    }

    print OUTHANDLE "$confline\n";
  }

  close INHANDLE or die;
  close OUTHANDLE or die;

  unlink("$filename") or die;
  rename("$filename.new", "$filename") or die;
}

foreach(qw/config.h Makefile/) {
  write_config($_);
}

print "\n\nsuccessfully configured your ethersex.\n";
print "don't forget to run `make clean all'.\n\n";
