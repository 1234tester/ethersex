#! /usr/bin/perl -w
# Copyright (c) 2007 by Stefan Siegl <stesie@brokenpipe.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# For more information on the GPL, please go to:
# http://www.gnu.org/copyleft/gpl.html

use strict;
use Term::Prompt;

my %ethersex_modules = (
  'tetrirape' => {
                   helptext  => "a tetrinet server",
                   conflicts => [ "ecmd", "bootloader" ],
                   distdflt  => 0,
                 },
  'ecmd'      => { 
                   helptext  => "telnet-based etherrape control interface",
                   conflicts => [ "tetrirape", "bootloader" ],
                   distdflt  => 1,
		   enable_hook => \&ecmd_enable_hook,
                 },
  'portio'    => {
                   helptext  => "port io abstraction layer",
                   distdflt  => 1,
                 },
  'named_pin'  => {
                   helptext => "pins with names and logic states",
                   requires  => [ "portio" ],
                   distdflt => 0,
                 },
  'ecmd_sender'  => {
                   helptext => "send an ecmd to another host",
                   requires => ["tcp"],
                   distdflt => 0,
                 },
  'watchcat'  => {
                   helptext => "watch io changes and react",
                   requires => ["ecmd_sender", "portio"],
                   distdflt => 0,
                 },
  'fs20'      => { 
                   helptext  => "fs20 rf-control interface",
                   distdflt  => 0,
                   conflicts => [ "bootloader" ],
                 },
  'bootp'     => { 
                   helptext  => "DHCP-like autoconfig for IPv4",
                   conflicts => [ "ipv6", "tftpomatic" ],
		   # require handled in enable-hook since we don't need to 
		   # do require here, if openvpn is enabled.
                   maybe_require  => [ "broadcast", "udp" ],
                   preconfigure => [ "ipv6" ],
                   distdflt  => 0,
		   enable_hook => \&bootp_enable_hook
                 },
  'bootp_to_eeprom' => {
                   helptext  => "store BOOTP-aquired data to EEPROM",
		   requires  => [ "bootp", "bootloader" ],
		   preconfigure => [ "bootp" ],
		   distdflt  => 0,
		 },
  'ipv6'      => { 
                   helptext  => "IPv6 support instead of IPv4",
                   conflicts => [ "bootp", "broadcast" ],
                   preconfigure => [ "enc28j60" ],
		   requires => [ "icmp" ],
                   distdflt  => 1,
                   enable_hook  => \&ipv6_enable_hook,
                   disable_hook  => \&ipv6_disable_hook,
                 },
  'broadcast' => { 
                   helptext  => "broadcast support",
                   requires  => [ "udp" ],
		   conflicts => [ "ipv6" ],
                   distdflt  => 0,
                 },
  'icmp'      => { 
                   helptext  => "icmp support",
                   distdflt  => 1,
                 },
  'udp'       => { 
                   helptext  => "udp support",
                   distdflt  => 1,
                 },
  'tcp'       => { 
                   helptext  => "tcp support",
                   distdflt  => 1,
                 },
  'rfm12_linkbeat_net' => {
                   helptext  => "send linkbeat packets on rfm12 link regularly (testing only)",
                   requires  => [ "rfm12" ],
                   distdflt  => 0,
                 },
  'zbus_linkbeat_net' => {
                   helptext  => "send linkbeat packets on rfm12 link regularly (testing only)",
		   requires  => [ "zbus" ],
                   distdflt  => 0,
                 },
  'udp_echo_net' => {
                   helptext  => "udp-bound echo application",
                   distdflt  => 0,
                 },
  'tftpomatic'=> {
                   helptext  => "automatic firmware loading using tftp",
                   requires  => [ "tftp" ],
                   conflicts => [ "bootp" ],
                   preconfigure => [ "bootp" ],
                   enable_hook  => \&tftpomatic_enable_hook,
                   distdflt  => 0,
                 },
  'tftp'      => { 
                   helptext  => "TFTP-based firmware bootloader",
                   requires  => [ "bootloader", "udp" ],
                   preconfigure => [ "tftpomatic", "skipjack" ],
                   enable_hook  => \&tftp_enable_hook,
                   distdflt  => 0,
                 },
  'hd44780'   => {
                   helptext  => "Character-LCD module driver",
                   distdflt  => 0,
                 },
  'bootloader'=> {
                   helptext  => "configure as bootloader",
		   requires  => [ "teensy" ],
                   distdflt  => 0,
                 },
  'skipjack'  => {
                   helptext  => "skipjack block cipher",
                   requires  => [ "crypto" ],
                   conflicts => [ "cast5" ],
                   distdflt  => 0,
                 },
  'cast5'     => {
                   helptext  => "cast5 block cipher",
                   requires  => [ "crypto" ],
                   conflicts => [ "skipjack", "bootloader" ],
                   distdflt  => 0,
                 },
  'md5'       => {
                   helptext  => "md5 hash support",
                   requires  => [ "crypto" ],
                   distdflt  => 0,
                 },
  'crypto'    => {
                   helptext  => "generic crypto support",
                   distdflt  => 0,
                   virtual   => 1,
                 },
  'openvpn'   => {
                   helptext  => "openvpn support",
		   distdflt  => 0,
		   preconfigure => [ "cast5", "md5" ],
		   enable_hook => \&openvpn_enable_hook,
                 },
  'stella'    => {
                   helptext  => "stella light support",
		   distdflt  => 0,
		   preconfigure => [ "udp" ],
                 },
  'teensy'    => {
                   helptext  => "try to keep flash memory needs minimal",
		   distdflt  => 0,
                 },
  'onewire'   => {
                   helptext  => "onewire device support",
                   distdflt  => 0,
                 },
  'rc5'       => {
                   helptext  => "sending rc5 IR codes",
                   distdflt  => 0,
		   conflicts => [ "rfm12" ],
                 },
  'rfm12'     => {
                   helptext  => "rfm12 fsk transmitter",
                   distdflt  => 0,
		   conflicts => [ "rc5" ],
		   enable_hook => \&rfm12_enable_hook,
		   preconfigure => [ "skipjack" ],
                 },
  'dns'       => {
                   helptext  => "dns name resolver",
                   distdflt  => 0,
                   requires => ["udp"],
                   preconfigure => [ "bootp" ],
                   enable_hook  => \&dns_enable_hook,
                 },
  'adc'       => {
                   helptext  => "get adc values",
                   distdflt  => 0,
                   requires => ["ecmd"],
                 },
  'dyndns'        => {
                   helptext  => "updating an dns name on dyn.metafnord.de",
                   distdflt  => 0,
                   requires => ["tcp"],
                   enable_hook  => \&dyndns_enable_hook,
                 },
  'syslog'        => {
                   helptext  => "sending syslog messages",
                   distdflt  => 0,
                   requires => ["udp"],
                   enable_hook  => \&syslog_enable_hook,
                 },
  'i2c'        => {
                   helptext  => "i2c to udp gateway",
                   distdflt  => 0,
                   conflicts => [ "i2c_slave" ],
                   requires => ["udp"],
                 },
  'i2c_slave'  => {
                   helptext  => "i2c slave to udp gateway",
                   distdflt  => 0,
                   conflicts => [ "i2c" ],
                   requires => ["udp"],
                   enable_hook  => \&i2c_slave_enable_hook,
                 },
  'clock'        => {
                   helptext  => "system clock",
                   distdflt  => 0,
                   enable_hook  => \&clock_enable_hook,
  },
  'clock_crystal'        => {
                   helptext  => "use crystal (32kHz) to tick system clock",
                   distdflt  => 0,
                   preconfigure => [ "clock" ],
                   requires => ["clock"],
                   conflicts => [ "stella" ],
                 },
  'dcf77'        => {
                   helptext  => "synchronize the clock with the dcf77 signal
                     (experimental)",
                   distdflt  => 0,
                   preconfigure => [ "clock" ],
                   requires => ["clock", "clock_crystal"],
                 },
  'ntp'        => {
                   helptext  => "get time via ntp protocol",
                   distdflt  => 0,
                   preconfigure => [ "clock" ],
                   requires => ["clock", "udp"],
                 },
  'ntpd'        => {
                   helptext  => "provide the system clock via ntp",
                   distdflt  => 0,
                   requires => ["clock", "udp"],
  },
  'enc28j60'  => {
                   helptext  => "enc28j60 ethernet controller",
                   distdflt  => 1,
		   enable_hook => \&enc28j60_enable_hook,
                 },
  'zbus'        => {
                   helptext  => "tunneling ip over zbus",
                   distdflt  => 0,
                   enable_hook => \&zbus_enable_hook,
                 },
  'ps2'        => {
                   helptext  => "ps2 keyboard",
                   distdflt  => 0,
                 },
  'hc595'        => {
                   helptext  => "use an hc595 as output expansion",
                   distdflt  => 0,
                 },
  'hc165'        => {
                   helptext  => "use an hc165 as input expansion",
                   distdflt  => 0,
                 },
  'sensormodul' => {
                   helptext  => "sensor modul mit KTY81, Feuchte Auswertung und LCD Anzeige",
                   distdflt  => 0,
                   requires => [ "udp" ],
                 },

);
my %ethersex_config = (
  'etherrape_ip' => {
                   helptext  => "default ip address (inner part, if OpenVPN)",
                 },
  'etherrape_ip4_netmask'   => {
                   helptext  => "default netmask (IPv4 only)",
                 },
  'etherrape_ip4_gateway'   => {
                   helptext  => "default gateway (IPv4 only)",
                 },
  'etherrape_mac'   => {
                   helptext  => "mac address of the etherrape",
                 },
  'zbus_ip' => {
                   helptext  => "zbus stack ip address",
                 },
  'zbus_key'   =>{
                   helptext  => "hex-encoded zbus encryption key",
                 },
  'rfm12_ip' => {
                   helptext  => "rfm12 stack ip address",
                 },
  'rfm12_key'   =>{
                   helptext  => "hex-encoded rfm12 encryption key",
                 },
  'i2c_slave_addr'   =>{
                   helptext  => "hex-encoded i2c slave address",
                 },
  'openvpn_ip4'   => {
                   helptext  => "ip address of the openvpn gateway",
                 },
  'openvpn_ip4_netmask'   => {
                   helptext  => "netmask for openvpn gateway",
                 },
  'openvpn_ip4_gateway'   => {
                   helptext  => "default gateway for openvpn gateway",
                 },
  'openvpn_key'   =>{
                   helptext  => "hex-encoded openvpn encryption key",
                 },
  'openvpn_hmac_key'   =>{
                   helptext  => "hex-encoded openvpn hmac auth key",
                 },
  'tftp_ip'   => {
                   helptext  => "ip address of tftp server",
                 },
  'tftp_image' =>{
                   helptext  => "name of tftp image to download",
                 },
  'tftp_key'   =>{
                   helptext  => "hex-encoded skipjack key for tftp",
                 },
  'dns_server' =>{
                   helptext  => "ip address of the default dns server",
                 },
  'dyndns_hostname' => {
                   helptext  => "hostname to be updated via dyndns",
                },
  'dyndns_username' => {
                   helptext  => "hostname to be updated via dyndns",
                },
  'dyndns_password' => {
                   helptext  => "hostname to be updated via dyndns",
                },
  'syslog_server' => {
                   helptext  => "ip address of the syslog server",
                },
);


my $opt_restore_defaults = 0;
my $opt_only_modules = 0;
foreach(@ARGV) {
  if(m/^--restore-defaults$/) { $opt_restore_defaults = 1; }
  if(m/^--only-modules$/) { $opt_only_modules = 1; }
  if(m/^--help$/ or m/^-h$/) { 
    print STDERR "ethersex configuration utility\n";
    print STDERR "  --restore-defaults  - enable only default modules\n";
    print STDERR "  --only-modules      - configure only the modules\n";
    print STDERR "  --disable-x         - disable feature 'x'\n";
    print STDERR "  --enable-x          - enable feature 'x'\n";
    print STDERR "  --D<option>=<value> - set option to value\n";
    exit 0;
  }
}

#
# scan `config.h' for enabled/disabled modules
#
open HANDLE, "< config.h"
  or die "unable to read config.h file";
while(<HANDLE>) {
  chop $_;
  if(my ($enabled, $modname) = 
     m/^(\/*|\/\/)?\s*#define\s+([A-Z0-9_]+)_SUPPORT\s*(?:\*\/)?\s*$/) {

    unless(defined($ethersex_modules{lc($modname)})) {
      warn "unknown ethersex module '" . lc($modname) . "' listed in config.h";
      next;
    }

    $ethersex_modules{lc($modname)}->{'enabled'} = !length($enabled);
  }
  if(my ($confopt, $confvalue) =
     m/#define\s+CONF_([A-Z0-9_]+)\s+(.*)$/) {

    unless(defined($ethersex_config{lc($confopt)})) {
      warn "unknown ethersex config '" . lc($confopt) . "' listed in config.h";
      next;
    }

    $ethersex_config{lc($confopt)}->{'value'} = $confvalue;
  }
}
close HANDLE or die;

my $opt_nogui = 0;
foreach(@ARGV) {
  if(m/--enable-([A-Z0-9_]+)/i) {
    if(defined($ethersex_modules{lc $1})
       && !defined($ethersex_modules{lc $1}->{'new_status'})
       && try_enable(lc $1) == 0) {
      $opt_nogui = 1;
      printf "enabling %s.\n", lc $1;
      enable(lc $1);
    }
    else {
      print "FAILED to enable $1.\n";
    }
  }

  if(m/--disable-([A-Z0-9_]+)/i) {
    if(defined($ethersex_modules{lc $1})
       && !defined($ethersex_modules{lc $1}->{'new_status'})) {
      $opt_nogui = 1;
      printf "disabling %s.\n", lc $1;
      disable(lc $1);
    }
    else {
      print "FAILED to disable $1.\n";
    }
  }
  if(m/^-D([^=]*)=(.*$)/) { 
    if (defined($ethersex_config{$1})) {
        $ethersex_config{$1}->{'user_value'} = $2;
        $opt_nogui = 1;
        print "setting $1 to $2.\n";
    } else {
      print STDERR "Invalid define option\n";
      exit -1;
    }
  }
}

# check whether module may be enabled
# return: 1 if conflicting (message will be emitted)
my @enable_modules;
my @disable_modules;
sub try_enable {
  my $module = shift;
  my $trymodule = shift;

  unless(defined($trymodule)) { $trymodule = $module }

  foreach my $module_conflicts (@{$ethersex_modules{$module}->{'conflicts'}}) {
    foreach (@enable_modules) {
      if($_ eq $module_conflicts) {
        printf "disabling %s (conflicts with %s).\n", $trymodule, $_;
        disable($trymodule);

        return 1;
      }
    }
  }

  foreach (@{$ethersex_modules{$module}->{'requires'}},
           @{$ethersex_modules{$module}->{'maybe_require'}}) {
    if(defined($ethersex_modules{$_}->{'new_status'})
       && !$ethersex_modules{$_}->{'new_status'}) {
      printf "disabling %s (would require %s).\n", $trymodule, $_;
      disable($trymodule);

      return 1;
    }
    if(try_enable($_, $trymodule)) {
      return 1;
    }
  }

  return 0;
}

sub enable {
  my $module = shift;
  my $requiring = shift;

  return if($ethersex_modules{$module}->{'new_status'});

  if(defined($requiring)) {
    printf "enabling %s (required by %s).\n", $module, $requiring;
  } else {
    $requiring = $module;
  }

  foreach (@{$ethersex_modules{$module}->{'requires'}}) {
    enable($_, $requiring);
  }

  $ethersex_modules{$module}->{'new_status'} = 1;
  push @enable_modules, $module;

  # call hook, if available
  if(!$opt_nogui && defined($ethersex_modules{$module}->{'enable_hook'})) {
    $ethersex_modules{$module}->{'enable_hook'}();
  }
}

sub disable {
  my $module = shift;
  $ethersex_modules{$module}->{'new_status'} = 0;
  push @disable_modules, $module;

  # call hook, if available
  if(!$opt_nogui && defined($ethersex_modules{$module}->{'disable_hook'})) {
    $ethersex_modules{$module}->{'disable_hook'}();
  }
}


# configure module (return 1, if config has been changed, 0 otherwise)
sub configure_module {
  my ($module) = @_;

 restart:
  # check whether we've already asked the user (or implied an answer)
  return(0) if(defined($ethersex_modules{$module}->{'new_status'}));

  return(0) if(try_enable($module));  # cannot enable, conflicting.

  # perform forced preconfiguration ...
  if(defined($ethersex_modules{$module}->{'preconfigure'})) {
    foreach (@{$ethersex_modules{$module}->{'preconfigure'}}) {
      if(configure_module($_)) { goto restart; }
    }
  }

  # automatic handling of virtual modules ...
  if($ethersex_modules{$module}->{'virtual'}) {
    # configure all modules depending on this module
    foreach (keys %ethersex_modules) { 
      next if $_ eq $module;
      next unless defined $ethersex_modules{$_}->{'requires'};
      foreach my $dependency (@{$ethersex_modules{$_}->{'requires'}}) {
        if($dependency eq $module) {
          if(configure_module($_)) { goto restart; }
        }
      }
    }
    
    print "disabling unneeded, virtual module $module.\n";
    disable $module;
    return 1;
  }

  my $answer;
  if($opt_restore_defaults) { 
    $answer = $ethersex_modules{$module}->{'distdflt'};
    printf "%s %s.\n", ($answer ? "enabling" : "disabling"), $module;
  }
  elsif($opt_nogui && defined($ethersex_modules{$module}->{'enabled'})) {
    $answer = $ethersex_modules{$module}->{'enabled'};
    printf "%s %s.\n", ($answer ? "enabling" : "disabling"), $module;
  }
  else {
    $answer = prompt('y', sprintf("enable %s?", $module),
                     $ethersex_modules{$module}->{'helptext'}, 
                     $ethersex_modules{$module}->{'enabled'});
  }

  if($answer) {
    enable($module);
  } 
  else {
    disable($module);
  }

  return 1;
}

sub ipv6_expand {
  my $ip = shift;
  my @colons = $ip =~ m/:/g;
  if(scalar(@colons) > 7) { return undef; }
  unless($ip =~ m/::/) { return $ip }

  my $replacement = ":0" x (8 - scalar(@colons)) . ":";
  $ip =~ s/::/$replacement/;
  if($ip =~ m/^:/) { $ip = "0$ip"; }
  if($ip =~ m/:$/) { $ip .= "0"; }

  return $ip;
}

# return 1 if provided IP address is valid
sub check_ip {
  my $checkval = shift;
  unless($ethersex_modules{'ipv6'}->{'new_status'}) {
    # validate ipv4 addr
    my @parts = split m/\./, $checkval;
    if(scalar(@parts) != 4) { return 0; }
    foreach(@parts) {
      if($_ < 0 || $_ > 255) { return 0; }
    }
    return 1;
  }

  # validate ipv6 addr
  if($checkval =~ m/:::/) { return 1; }
  $checkval = ipv6_expand($checkval);
  if($checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){7}$/i) { return 1; }
  return 0;
}

sub ask_ip {
  my $confopt = shift;
  my $new_value;

  configure_module "ipv6";
  if (defined($ethersex_config{$confopt}->{'user_value'})) {
    $new_value = $ethersex_config{$confopt}->{'user_value'};
    goto save_value;
  }

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }
  for($default) { s/0x//g; s/\s//g; s/^uip_ip6?addr\(ip,//; s/\)$//; }
  my $separator = $ethersex_modules{'ipv6'}->{'new_status'} ? ":" : ".";
  $default = join($separator, split(m/,/, $default));
  unless (check_ip($default)) { $default = "" }

  $new_value = 
    prompt('s', $confopt . "?", $ethersex_config{$confopt}->{'helptext'}, 
           $default, \&check_ip);

save_value:
  if($ethersex_modules{'ipv6'}->{'new_status'} && $new_value =~ m/::/) {
    $new_value = ipv6_expand($new_value);
  }

  my @parts = split(m/[\.:]/, $new_value);
  if($ethersex_modules{'ipv6'}->{'new_status'}) {
    foreach(@parts) { $_ = "0x" . $_ }
  }
  $ethersex_config{$confopt}->{'value'} = "uip_" .
    ($ethersex_modules{'ipv6'}->{'new_status'} ? "ip6addr" : "ipaddr") . "(ip,"
    . join(",", @parts) . ")"; 
}

sub check_mac {
  my $checkval = shift;
  if ($checkval =~ m/^[0-9a-f]+(?::[0-9a-f]+){5}$/i) { return 1;}
  return 0;
}

sub ask_mac {
  my $confopt = shift;
  my $new_value;

  if($opt_restore_defaults) {
    $ethersex_config{$confopt}->{'value'} = '"\xAC\xDE\x48\xFD\x0F\xD0"';
    return;
  }

  if (defined($ethersex_config{$confopt}->{'user_value'})) {
    $new_value = $ethersex_config{$confopt}->{'user_value'};
    goto save_value;
  }

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  for($default) { s/"//g; s/\\x/:/g; s/^:// };
  $new_value =
    prompt('s', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, \&check_mac);
save_value:
  for($new_value) {s/:/\\x/g }
  
  $ethersex_config{$confopt}->{'value'} = '"\\x' . $new_value . '"';
}

sub ask_anything {
  my $confopt = shift;
  my $new_value;

  if (defined($ethersex_config{$confopt}->{'user_value'})) {
    $new_value = $ethersex_config{$confopt}->{'user_value'};
  } else {
    my $d = $ethersex_config{$confopt}->{'value'};
    unless(defined($d)) { $d = ""; }
    for($d) { s/^"//; s/"$//; }

    $new_value =
      prompt('x', $confopt . "?", $ethersex_config{$confopt}->{'helptext'}, $d); 
  }
  $ethersex_config{$confopt}->{'value'} = "\"$new_value\"";
}

# check key validity, return 0 if invalid.
sub check_cryptokey {
  my $checkval = shift;
  my $keylen = shift;

  unless (length ($checkval) == $keylen * 2) { return 0; }
  unless ($checkval =~ m/^[0-9a-f]+$/i) { return 0; }
  return 1;
}

sub ask_cryptokey {
  my $confopt = shift;
  my $keylen = shift;

  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  for($default) { s/"//g; s/\\x//g; };
  my $new_value =
    prompt('s', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, 
           sub { 
             my $a = shift; 
             return check_cryptokey ($a, $keylen); 
           } );

  $new_value =~ s/(..)/\\x$1/g;
  $ethersex_config{$confopt}->{'value'} = "\"$new_value\"";
}

sub ask_hex {
  my $confopt = shift;
  my $hexlen = shift;
  $hexlen = $hexlen * 2;
  my $default = $ethersex_config{$confopt}->{'value'};
  unless(defined($default)) { $default = "" }

  $default =~ s/0x//;
  my $new_value =
    prompt('e', $confopt, $ethersex_config{$confopt}->{'helptext'}, 
           $default, "[A-F0-9]{$hexlen}");

  $new_value =~ s/^/0x/;
  $ethersex_config{$confopt}->{'value'} = "$new_value";
}

sub enc28j60_enable_hook {
  ask_mac "etherrape_mac";
}

sub tftpomatic_enable_hook {
  # don't ask for tftp image, if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});

  ask_ip("tftp_ip");
  ask_anything("tftp_image");
}

sub tftp_enable_hook {
  # ask for crypto key only if skipjack enabled.
  return unless($ethersex_modules{'skipjack'}->{'new_status'});

  ask_cryptokey("tftp_key", 10);
}

sub ecmd_enable_hook {
  if ($ethersex_modules{'teensy'}->{'new_status'}) {
    enable("udp", "ecmd and teensy");
  } else {
    enable("tcp", "ecmd");
  }
}

sub bootp_enable_hook {
  # ask user for openvpn support (we won't need to enable udp/broadcast then)
  configure_module "openvpn";
  return if($ethersex_modules{'openvpn'}->{'new_status'});
  
  enable "udp", "bootp";
  enable "broadcast", "bootp";
}

sub ipv6_enable_hook {
  # ask user for openvpn support (we won't need a gateway on inner stack otherwise)
  configure_module "openvpn";

  ask_ip("etherrape_ip")
    if($ethersex_modules{'openvpn'}->{'new_status'} == 1
       || $ethersex_modules{'enc28j60'}->{'new_status'} == 0);
}

sub zbus_enable_hook {
  ask_ip("zbus_ip") if($ethersex_modules{'enc28j60'}->{'new_status'});

  return unless($ethersex_modules{'skipjack'}->{'new_status'});
  ask_cryptokey("zbus_key", 10);
}

sub rfm12_enable_hook {
  ask_ip("rfm12_ip") if($ethersex_modules{'enc28j60'}->{'new_status'});

  return unless($ethersex_modules{'skipjack'}->{'new_status'});
  ask_cryptokey("rfm12_key", 10);
}

sub i2c_slave_enable_hook {
  ask_hex("i2c_slave_addr", 1) if($ethersex_modules{'i2c_slave'}->{'new_status'});

}

sub ipv6_disable_hook {
  # ask user for openvpn support (we won't need a gateway on inner stack otherwise)
  configure_module "openvpn";

  unless ($ethersex_modules{'openvpn'}->{'new_status'}) {
    # ask user for bootp (we won't have to configure IPs otherwise)
    # if openvpn support is disabled.  when openvpn is configured we
    # need to assign static ips on the inner layer no matter what.
    configure_module "bootp";

    # don't ask default ip if user configured bootp
    return if($ethersex_modules{'bootp'}->{'new_status'});
  }
  
  ask_ip("etherrape_ip");
  
  # don't ask for netmask and gateway, if we don't have ethernet support
  configure_module "enc28j60";
  return unless($ethersex_modules{'enc28j60'}->{'new_status'});

  ask_ip("etherrape_ip4_netmask");

  if($ethersex_modules{'openvpn'}->{'new_status'}) {
    print "configuring etherrape_ip4_gateway to 0.0.0.0 (openvpn enabled).\n";
    $ethersex_config{"etherrape_ip4_gateway"}->{'value'} =
      "uip_ipaddr(ip,0,0,0,0)"
  } 
  else {
    ask_ip("etherrape_ip4_gateway");
  }
}

sub openvpn_enable_hook {
  print "** WARNING ** tunneled traffic will not be encrypted!\n\n"
    unless($ethersex_modules{'cast5'}->{'new_status'});
  print "** WARNING ** tunneled traffic will not be authenticated!\n\n"
    unless($ethersex_modules{'md5'}->{'new_status'});

  # ask user for bootp (we won't have to configure IPs otherwise)
  configure_module "bootp";

  # don't ask for ip if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});
  
  unless($ethersex_modules{'ipv6'}->{'new_status'}) {
    ask_ip("openvpn_ip4");
    ask_ip("openvpn_ip4_netmask");
    ask_ip("openvpn_ip4_gateway");
  }

  ask_cryptokey("openvpn_key", 16)
    if($ethersex_modules{'cast5'}->{'new_status'});
  ask_cryptokey("openvpn_hmac_key", 16)
    if($ethersex_modules{'md5'}->{'new_status'});
}

sub dns_enable_hook {
  # don't ask for dns server, if user configured bootp
  return if($ethersex_modules{'bootp'}->{'new_status'});

  ask_ip("dns_server");
}

sub dyndns_enable_hook {
  ask_anything("dyndns_hostname");
  ask_anything("dyndns_username");
  ask_anything("dyndns_password");
}

sub syslog_enable_hook {
  ask_ip("syslog_server");
}

sub clock_enable_hook {
  enable("clock_crystal", "clock and teensy") 
    if ($ethersex_modules{'teensy'}->{'new_status'});
}

#
# ask user which modules to enable
#
if ( $opt_only_modules != 1) {
  print "\n\n -= ETHERSEX CONFIGURATION =-\n\n";
  configure_module "bootloader";
  configure_module "teensy";
  foreach my $module (keys %ethersex_modules) { configure_module($module) }
}

#
# deferred disable/enable hook handling ...
#
if ($opt_nogui) {
  foreach (@enable_modules) {
    if(defined($ethersex_modules{$_}->{'enable_hook'})) {
      $ethersex_modules{$_}->{'enable_hook'}();
    }
  }

  foreach (@disable_modules) {
    if(defined($ethersex_modules{$_}->{'disable_hook'})) {
      $ethersex_modules{$_}->{'disable_hook'}();
    }
  }
}

#
# update config files ...
#
sub write_config {
  my $filename = shift;
  print "writing $filename.\n";

  open INHANDLE, "< $filename"
    or die "unable to open $filename for reading";
  open OUTHANDLE, "> $filename.new"
    or die "unable to open $filename.new for writing";

  while(my $confline = <INHANDLE>) {
    chop $confline;
    my ($enabled, $modname, $line);

    # enable/disable config.h support flag
    if(($enabled, $modname) = $confline =~
       m/^(\/*|\/\/)?\s*#define\s+([A-Z0-9_]+)_SUPPORT\s*(?:\*\/)?\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "// ") . "#define " . $modname . "_SUPPORT";
      }
      # commit config for later module configuration
      $ethersex_modules{lc($modname)}->{'enabled'} =
        $ethersex_modules{lc($modname)}->{'new_status'};
    }

#   # enable/disable Makefile SRC variable editing
#   elsif(($modname) = $confline =~
#      m/^#*\s*SRC\s*\+=\s*\$\(shell echo ([a-z0-9_]+)\/\*\.c\)\s*$/) {
#
#     if(defined($ethersex_modules{lc($modname)})) {
#       $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
#                   ? "" : "#") . "SRC += \$(shell echo $modname/*.c)";
#     }
#   }

    elsif(($modname) = $confline =~
       m/^#*\s*SUBDIRS\s*\+=\s*([a-z0-9_]+)\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "#") . "SUBDIRS += $modname";
      }
    }

    # enable/disable Makefile lines ...
    elsif(($line, $modname) = $confline =~
       m/^#*\s*([^#]+#\s*([A-Z0-9_]+)_SUPPORT)\s*$/) {

      if(defined($ethersex_modules{lc($modname)})) {
        $confline = ($ethersex_modules{lc($modname)}->{'new_status'} 
                    ? "" : "#") . $line;
      }
    }

    # write configuration option
    elsif(($modname) = $confline =~
          m/#define\s+CONF_([A-Z0-9_]+)\s+/) {

      if(defined($ethersex_config{lc($modname)})) {
        $confline = "#define CONF_$modname " 
          . $ethersex_config{lc($modname)}->{'value'};
      }
    }

    print OUTHANDLE "$confline\n";
  }

  close INHANDLE or die;
  close OUTHANDLE or die;

  unlink("$filename") or die;
  rename("$filename.new", "$filename") or die;
}


# make sure config.mk exists
unless (-e "config.mk") { system "make no_deps=t config.mk"; }

#
# write the config files
#
if ($opt_only_modules != 1) {
  foreach(qw/config.h config.mk Makefile/) {
    write_config($_);
  }
}

sub modules_configuration {
  my %configure_modules = ();

  foreach my $module (keys %ethersex_modules) {
    if (-e("$module/configure") and -e("$module/cfgpp")
        and $ethersex_modules{$module}->{'enabled'}) {
      $configure_modules{$module} = $ethersex_modules{$module};
    }
  }
  return unless scalar(keys %configure_modules);

  my $choice;
  do {
    print "\n== configure ethersex modules ==\n\n";
    my $x = 1;
    foreach my $t (keys(%configure_modules)) {
      print "$x. $t - " . $configure_modules{$t}->{'helptext'} . "\n";
      $x++;
    }
    print "\n0. Exit\n";

    $choice = prompt('n', 'Please Choose:', '', '0');
    if($choice > scalar(keys %configure_modules)) {
      print "invalid choice, try again.\n\n";
      next;
    }

    if($choice) {
      system((keys(%configure_modules))[$choice - 1] . "/configure");
    }

  } while ($choice);
}

#
# configure the selected modules
#

modules_configuration

print "\n\nsuccessfully configured your ethersex.\n\n";
