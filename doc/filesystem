etherrape dataflash filesystem description
==========================================

Resources:
* introduction about filesystems on flash mediums: http://sources.redhat.com/jffs2/jffs2.pdf
* AT45DB161D datasheet: http://atmel.com/dyn/resources/prod_documents/doc3500.pdf

All integers are Host-Endian!

Defintions:
* page: physical memory unit on the dataflash (528 byte in this case)
* node: virtual entity storing data with unique node number (32bit integer,
  always increasing), stores data in many pages


The dataflash used in the etherrape consists of 4096 pages, 528 bytes each (16
bytes will be used as structure information and 512 bytes can be used for data
storage.)  Two 528 byte SRAM buffers can be used read, modify and write
content.  Additionally, data can directly be read from flash, circumventing
the SRAM buffers.  See AT45DB161D datasheet for details.

The dataflash api consists of these functions:
* read_flash(page_address, offset, *data, len)
    load data from page to memory
        page_address in 0..4095
        offset in 0..527
        data target buffer
        len in 528-offset
* load_buffer(buffer, page_address)
    load page to buffer (in flash)
        buffer in 1, 2 (buffer 1 and 2)
        page_address in 0..4095
* read_buffer(buffer, offset, *data, len)
    buffer to memory
        buffer in 1, 2
        offset in 0..527
        data target memory
        len in 528-offset
* write_buffer(buffer, offset, *data, len)
    copy memory to buffer
        buffer in 1, 2
        offset in 0..527
        data target memory
        len in 528-offset
* save_buffer(buffer, page_address)
    write buffer to page
        buffer in 1, 2
        page_address in 0..4095
* erase_page(page_address)
    erase page (all bytes 0xFF)
        page_address in 0..4095

Each page on the dataflash consists of:
* 16 bytes structure information, namely:
  * 8bit: magic byte, 0xFF if erased, 0x23 if used
  * 32bit: node number
  * 16bit: index of this page in the node
  * 32bit: version (always increasing, only pages with same node number and
           highest version are valid, this helps providing "wear levelling")
  * 16bit: pointer to the next page for this node
  * 8bit: content-type
  * 2 bytes reserved
* 512 bytes of data, if index is 0 the data is preceeded by a nullterminated
  description string (aka "filename").

Valid content-types:
- 0x00: structure information
- 0x01: simple file (for webserver, eg. javascript and html-files)
- 0x02: crontab
- 0x03: temperature record

The directory hirarchy starts at node number 0, at boot the page with node
number 0, index 0 and the highest version is searched, this is also known as
the root node.

vim:tw=76
